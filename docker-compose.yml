services:
  # 1. Base de Datos (PostgreSQL)
  postgres:
    image: postgres:16-alpine
    container_name: cipheraudit-postgres
    environment:
      POSTGRES_DB: cipheraudit
      POSTGRES_USER: cipher
      POSTGRES_PASSWORD: SuperSecret123!
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./infra/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    networks:
      - ciphernet
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s

  # 2. Broker de Mensajería (RabbitMQ)
  rabbitmq:
    image: rabbitmq:3.13-management-alpine
    container_name: cipheraudit-rabbitmq
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}
    ports:
      - "127.0.0.1:15672:15672" # Management UI solo local
      - "5672:5672" # Puerto AMQP
    networks:
      - ciphernet
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 15s

  # 3. Microservicio C# (Productor)
  csharp-producer:
    build: ./services/csharp-producer
    container_name: cipheraudit-csharp
    environment:
      ASPNETCORE_URLS: "http://+:8080"
      DB_HOST: "postgres"
      RMQ_HOST: "rabbitmq"
    networks:
      - ciphernet
    # Depende de que las infraestructuras estén sanas
    depends_on:
      rabbitmq:
        condition: service_healthy
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s # Permite tiempo para la compilación JIT

  # 4. Java BFF (Consumidor)
  java-bff:
    build: ./services/java-bff
    container_name: cipheraudit-java
    environment:
      SPRING_PROFILES_ACTIVE: docker
      DB_HOST: "postgres"
      RMQ_HOST: "rabbitmq"
    # LÓGICA DE ESPERA EN SHELL CRÍTICA
    command: >
      sh -c "
      until nc -z rabbitmq 5672 && nc -z postgres 5432; 
      do echo 'Esperando a RabbitMQ y Postgres...'; sleep 3; 
      done;
      java -jar /app/app.jar"
    networks:
      - ciphernet
    # Dependencia lógica para el orquestador
    depends_on:
      rabbitmq:
        condition: service_healthy
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # 5. Frontend React (Nginx-Free 'serve')
  sentinel-front:
    build: ./services/sentinel-front
    container_name: cipheraudit-frontend
    networks:
      - ciphernet
    # Solo dependencia lógica (el front debe cargar)
    depends_on:
      java-bff:
        condition: service_healthy
    # El puerto 3000 fue definido en el Dockerfile de 'serve'

  # 6. API Gateway (Kong Declarativo)
  kong:
    image: kong:3.6.0
    container_name: cipheraudit-kong
    environment:
      KONG_DATABASE: "off" # Modo Declarativo sin DB
      KONG_DECLARATIVE_CONFIG: /kong/declarative/kong.yml
      KONG_PROXY_LISTEN: 0.0.0.0:8000
      KONG_ADMIN_LISTEN: 127.0.0.1:8001
    volumes:
      - ./infra/kong/declarative:/kong/declarative
    ports:
      - "80:8000" # TRÁFICO EXTERNO
      # Eliminamos el puerto admin expuesto para seguridad
    networks:
      - ciphernet
    # CRÍTICO: Kong se inicia primero. No depende de los backends.
    depends_on: 
      rabbitmq: # Incluimos RabbitMQ porque el Health Check de Kong podría usarlo
        condition: service_healthy
    healthcheck:
      test: ["CMD", "kong", "health"]
      interval: 10s
      timeout: 5s
      retries: 5

networks:
  ciphernet:
    driver: bridge

volumes:
  postgres_data: